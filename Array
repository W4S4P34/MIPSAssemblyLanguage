.data
	# Statements
	ArrayInput:	.asciiz "Number of elements (0 < n <= 1000): "
	ArrayTraversal:	.asciiz "Element no."	

	MenuTitle:	.asciiz "Function Menu:\n"
	Function1:	.asciiz "1. Print out all elements.\n"
	Function2:	.asciiz "2. Sum all elements.\n"
	Function3:	.asciiz "3. List all prime elements.\n"
	Function4:	.asciiz "4. Find max.\n"
	Function5:	.asciiz "5. Find input element.\n"
	Function6:	.asciiz "6. Exit.\n"
	
	Result:		.asciiz "Result: "

	Selection:	.asciiz "Select: "

	Reset:		.asciiz "Continue? (1/2) 1. Yes, 2. No\n"

	OutOfRange:	.asciiz "Out of range! Select again!\n"
	ExitAnnounce:	.asciiz "Exit Sucessfully!"

	# Escape Sequence
	CR:		.asciiz "\n"
	Spacebar:	.asciiz " "
	Colon:		.asciiz ": "

.text
	.globl main

main:
	la	$a0, ArrayInput		# Input number of elements
	li	$v0, 4
	syscall

	li	$v0, 5
	syscall

	move	$t0, $v0

	bgt 	$t0, 1000, outRange	# If n <= 0 or n > 1000, announce then reset
	blt 	$t0, 1, outRange

	move	$s0, $t0		# $s0 contains n

	li	$t1, 4

	mult	$t0, $t1
	mflo	$t0

	move	$s1, $t0		# $s1 contains n x 4 byte

	li	$t1, -1

	mult	$t0, $t1
	mflo	$t0

	add	$sp, $sp, $t0		# Declare array with n elements, each has 4 byte

	#**********************#
	jal 	initArray

	#**********************#
	jal 	showMenu

	#**********************#
	jal 	selectFunction

	j	exit

#*********************************************************#
initArray:
	li	$t0, 0			# $t0 contains index of array
	la	$t1, ($sp)		# $t1 and $sp contain the address of the first element of stack

	j	LoopInitArray

LoopInitArray:
	li	$v0, 4
	la	$a0, ArrayTraversal
	syscall

	li	$v0, 1
	add	$a0, $0, $t0
	syscall

	li	$v0, 4
	la	$a0, Colon
	syscall

	li	$v0, 5
	syscall

	sw	$v0, ($t1)
	
	addi	$t1, $t1, 4
	addi	$t0, $t0, 1

	bne	$t0, $s0, LoopInitArray
	jr	$ra
	

#*********************************************************#
showMenu:
	la	$a0, MenuTitle		# Show menu title
	li	$v0, 4			# Load $v0 with 4 to print string
	syscall

	la	$a0, Function1		# Show functions
	li	$v0, 4			# Load $v0 with 4 to print string
	syscall

	la	$a0, Function2		# Show functions
	li	$v0, 4			# Load $v0 with 4 to print string
	syscall
	
	la	$a0, Function3		# Show functions
	li	$v0, 4			# Load $v0 with 4 to print string
	syscall

	la	$a0, Function4		# Show functions
	li	$v0, 4			# Load $v0 with 4 to print string
	syscall

	la	$a0, Function5		# Show functions
	li	$v0, 4			# Load $v0 with 4 to print string
	syscall

	la	$a0, Function6		# Show functions
	li	$v0, 4			# Load $v0 with 4 to print string
	syscall

	jr	$ra			# Return to main


selectFunction:
	la	$a0, Selection		# Show selection title
	li	$v0, 4			# Load $v0 with 4 to print string
	syscall

	li	$v0, 5
	syscall

	move	$t0, $v0

	bgt 	$t0, 6, outRange
	blt 	$t0, 1, outRange

	#**********************#
	beq	$t0, 1, selectF1

	#**********************#
	beq	$t0, 2, selectF2

	#**********************#
	beq	$t0, 3, selectF3
	
	#**********************#
	beq	$t0, 4, selectF4

	#**********************#
	beq	$t0, 5, selectF5

	jr	$ra


#*********************************************************#
selectF1:
	li	$t0, 0			# $t0 contains index of array
	la	$t1, ($sp)		# $t1 and $sp contain the address of the first element of stack

	li	$v0, 4
	la	$a0, Result
	syscall	

	j	LoopF1

LoopF1:
	li	$v0, 1
	lw	$a0, ($t1)
	syscall

	li	$v0, 4
	la	$a0, Spacebar
	syscall

	addi	$t1, $t1, 4
	addi	$t0, $t0, 1

	bne	$t0, $s0, LoopF1	

	li	$v0, 4
	la	$a0, CR
	syscall
	
	j 	reset


#*********************************************************#
selectF2:
	li	$t0, 0			# $t0 contains index of array
	la	$t1, ($sp)		# $t1 and $sp contain the address of the first element of stack

	li	$v0, 4
	la	$a0, Result
	syscall	

	li	$a0, 0			# Sum of elements variable

	j	LoopF2

LoopF2:
	lw	$t2, ($t1)		# Get current element
	add	$a0, $a0, $t2

	addi	$t1, $t1, 4
	addi	$t0, $t0, 1

	bne	$t0, $s0, LoopF2

	li	$v0, 1
	syscall

	li	$v0, 4
	la	$a0, CR
	syscall
	
	j 	reset


#*********************************************************#
selectF3:
	li	$t0, 0			# $t0 contains index of array
	la	$t1, ($sp)		# $t1 and $sp contain the address of the first element of stack

	li	$v0, 4
	la	$a0, Result
	syscall	

	j	LoopF3

LoopF3:
	

	addi	$t1, $t1, 4
	addi	$t0, $t0, 1

	bne	$t0, $s0, LoopF3	

	li	$v0, 4
	la	$a0, CR
	syscall
	
	j 	reset


#*********************************************************#
selectF4:
	li	$t0, 0			# $t0 contains index of array
	la	$t1, ($sp)		# $t1 and $sp contain the address of the first element of stack

	li	$v0, 4
	la	$a0, Result
	syscall	

	li	$a0, 0			# Max variable

	j	LoopF4

LoopF4:
	lw	$t2, ($t1)		# Get current element

	sgt	$t3, $t2, $a0
	bne	$t3, 1, AssignMaxElse

AssignMax:
	add	$a0, $0, $t2

AssignMaxElse:
	addi	$t1, $t1, 4
	addi	$t0, $t0, 1

	bne	$t0, $s0, LoopF4	

	li	$v0, 1
	syscall

	li	$v0, 4
	la	$a0, CR
	syscall
	
	j 	reset


#*********************************************************#
selectF5:
	li	$t0, 0			# $t0 contains index of array
	la	$t1, ($sp)		# $t1 and $sp contain the address of the first element of stack

	li	$v0, 4
	la	$a0, Result
	syscall	

	j	LoopF5

LoopF5:
	

	addi	$t1, $t1, 4
	addi	$t0, $t0, 1

	bne	$t0, $s0, LoopF5	

	li	$v0, 4
	la	$a0, CR
	syscall
	
	j 	reset


#*********************************************************#
outRange:
	la	$a0, OutOfRange
	li	$v0, 4
	syscall

	j	reset


reset:
	la	$a0, Reset		# Reset question
	li	$v0, 4			# Load $v0 with 4 to print string
	syscall

	la	$a0, Selection		# Show selection title
	li	$v0, 4			# Load $v0 with 4 to print string
	syscall

	li	$v0, 5
	syscall

	move 	$t0, $v0

	bgt 	$t0, 2, outRange
	blt 	$t0, 1, outRange

	beq	$t0, 1, main
	beq	$t0, 2, exit


exit:
	add	$sp, $sp, $s1		# Free array

	la	$a0, ExitAnnounce	# Announce the exit state
	li	$v0, 4			# Load $v0 with 4 to print string
	syscall

	li 	$v0, 10			# Load $v0 with 10 to exit
	syscall
